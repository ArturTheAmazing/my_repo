#Клиентский сценарий
*см. architecture.png для графического представления архитектуры*

**Client** имеет доступ до двух баз:
1. Products DBMS;
2. Users DBMS.

**Products DBMS** помимо прочих таблиц имеет таблицу с данными об услугах:
1. ID услуги;
2. Название услуги;
3. Описание услуги;
4. Стоимость услуги.

**Users DBMS** хранит данные о пользователях.

Перед отправкой запроса на проведение транзакции 
**Client** получает ID пользователя, для которого нужно провести транзакцию, 
и ID услуги, которую пользователь хочет приобрести.
Эти данные **Client** логирует.

**Client** и **Интерфейс администратора** отправляют REST-запросы на 
**балансировщик**, который определяет ноду для проксирования запроса 
*(см. api.yaml в Swagger для спецификации API)*.


Нода **Payment service** валидириует данные и в случае успешной валидации 
отправляет запрос на сервер соответствующего банка-эмитента 
(адреса серверов можно забить в конфиге кластера, например, если это OpenShift).
При получении ответа сервис парсит его и 
возвращает ответ **Client** через **балансировщик**.
При этом ноды **Payment service** используют **redis** в качестве кэша.

Метрики собираются **Prometheus** через **экспортеры** из **балансировщика** 
и вышеупомянутого инстанса **redis**.

**Grafana** берет данные из **Prometheus** и **DB Mon (Monitoring DB)** 
для составления отчетов.